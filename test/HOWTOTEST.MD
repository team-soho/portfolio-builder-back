# How to Test

---
프로젝트를 진행하기 앞서 portfolio-builder-back 의 TDD 규칙을 작성한다. 해당 규칙과 TDD 원칙에 맞춰 코드를 작성하는 것을 지향한다.

1. **테스트를 먼저 작성 (🔴 Red)**:
    - 개발자는 아직 구현되지 않은 기능에 대한 테스트 케이스를 먼저 작성한다. 이 테스트는 현재 실패해야 한다. 왜냐하면 아직 기능이 구현되지 않았기 때문이다.

2. **코드 작성 (🟢 Green)**:
    - 테스트를 통과하기 위한 최소한의 코드를 작성한다. 이 코드는 테스트를 통과하도록 만들기 위한 목적 달성에 초점을 맞춘다.

3. **리팩토링 (🟡 Refactor)**:
    - 작성한 코드를 리팩토링하여 코드의 가독성, 유지보수성, 성능 등을 향상시킨다. 이때, 코드의 동작을 변경하지 않고 구조를 개선하는 것이 중요하다.

   제일 중요한것은 처음부터 완벽하려 하지 않는 것
   테스트 코드는 최소한으로만 mocking
   점진적으로 상세화 하기 잊지 말기

### index

1. 테스트 작성 순서
2. nestjs 에서 jest 환경에서 faker 사용 하여 mock 만드는 법
3. 고려해보았으나 리스크 있어서 안쓰는 것
    1. test decorator 로 자동 mock data 생성
    2. json file 로 관리
    3. 외부 라이브러리 사용 (`ts-mockito`, `jest-mock-extended`)

---

## 테스트 작성 순서

1. 요구 사항 분석 및 계획

2. e2e 테스트 작성

3. nest js 기본 domain 구조 작성

4. service.spec 작성

5. service 작성 & testing

6. controller.spec 작성

7. controller 작성 & testing

8. e2e, unit testing

9. refactoring

10. 반복

---

## 고려 사항 (계속 추가)

1. **Test Decorator로 자동 Mock Data 생성**:
    - Decorator를 사용한 자동 Mock 데이터 생성 방식은 코드의 복잡성을 증가시키고, 테스트의 예측 가능성을 저하시킬 수 있다.
    - 테스트 환경에서만 작동하도록 하는 추가적인 구현이 필요하다 그렇지 않으면 성능에 영향을 줄 수 있다..

2. **JSON File로 관리**:
    - 테스트 데이터 업데이트가 번거로울 수 있다.

3. **외부 라이브러리 사용 (`ts-mockito`, `jest-mock-extended`)**:
    - 이러한 라이브러리는 유용한 기능을 제공하지만, 프로젝트의 의존성을 증가시키고, 학습 곡선을 높일 수 있다.
    - NestJS와 Jest의 기본 기능만으로도 충분히 효과적인 테스트 구현이 가능하다.
    - 무엇 보다 `ts-mockito` 는 업데이트가 멈췄다...
    - `jest-mock-extended` 의 경우 jest mock보다 뛰어난 점을 잘 모르겠다

4. **Faker 사용시 고려사항**:
    - `faker`를 사용하여 테스트 데이터를 생성하는 것은 유용할 수 있지만, 매번 다른 데이터가 생성되어 테스트의 재현성 문제를 야기할 수 있다.
    - 특정 조건이나 에지 케이스를 일관되게 테스트하기 어려워질 수 있다. 
    - 필요한 경우, `faker`에서 제공하는 시드(seed) 기능을 사용하여 일관된 데이터 생성을 보장해야 한다. (그럴거면 왜쓰는지...)

5. **동적 테스트 데이터 생성의 과도한 사용**:
    - 테스트에서 동적 데이터 생성을 과도하게 사용하는 것은 테스트의 예측 가능성을 저하시키고, 디버깅을 어렵게 만들 수 있다.
    - 테스트의 명확성과 재현성을 유지하기 위해, 고정된 테스트 데이터를 사용하는 것이 종종 더 바람직하다.
